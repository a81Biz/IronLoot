// ===========================================
// Iron Loot - Prisma Schema
// ===========================================
// This schema defines the database structure for Iron Loot
// Reference: 03-modelo-registro-db.md

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===========================================
// USER & AUTH TABLES
// ===========================================

/// User states enum
enum UserState {
  PENDING_VERIFICATION
  ACTIVE
  SUSPENDED
  BANNED
}

/// Auction status enum
enum AuctionStatus {
  DRAFT
  PUBLISHED
  ACTIVE
  CLOSED
  CANCELLED
}

/// User - Main user entity
model User {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Authentication
  email        String @unique @db.VarChar(255)
  username     String @unique @db.VarChar(50)
  passwordHash String @map("password_hash") @db.VarChar(255)

  // 2FA
  twoFactorSecret    String?   @map("two_factor_secret") @db.VarChar(100)
  isTwoFactorEnabled Boolean   @default(false) @map("is_two_factor_enabled")

  // Profile
  displayName String? @map("display_name") @db.VarChar(100)
  avatarUrl   String? @map("avatar_url") @db.Text

  // State
  // State
  state           UserState @default(PENDING_VERIFICATION)
  suspendedReason String?   @map("suspended_reason") @db.Text
  bannedReason    String?   @map("banned_reason") @db.Text

  // Preferences (Spec v0.2.3)
  settings Json @default("{\"language\": \"es\", \"notifications\": {\"email\": true, \"inApp\": true}}") @db.JsonB

  // Seller status
  isSeller        Boolean   @default(false) @map("is_seller")
  sellerEnabledAt DateTime? @map("seller_enabled_at") @db.Timestamptz

  // Financial
  wallet Wallet?

  // Email verification
  emailVerifiedAt            DateTime? @map("email_verified_at") @db.Timestamptz
  emailVerificationToken     String?   @map("email_verification_token") @db.VarChar(255)
  emailVerificationExpiresAt DateTime? @map("email_verification_expires_at") @db.Timestamptz

  // Password reset
  passwordResetToken     String?   @map("password_reset_token") @db.VarChar(255)
  passwordResetExpiresAt DateTime? @map("password_reset_expires_at") @db.Timestamptz

  // Relations
  sessions        Session[]
  profile         Profile?
  auctions        Auction[] // Relation as seller
  bids            Bid[] // Relation as bidder
  watchlist       Watchlist[]
  ordersAsBuyer   Order[]        @relation("OrdersBuyer")
  ordersAsSeller  Order[]        @relation("OrdersSeller")
  authoredRatings Rating[]       @relation("RatingAuthor")
  receivedRatings Rating[]       @relation("RatingTarget")
  createdDisputes Dispute[]      @relation("DisputeCreator")
  notifications   Notification[]

  @@index([email], name: "idx_users_email")
  @@index([username], name: "idx_users_username")
  @@index([state], name: "idx_users_state")
  @@map("users")
}

/// Profile - Extended user profile data
model Profile {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relation
  userId String @unique @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Contact info
  phone     String? @db.VarChar(20)
  legalName String? @map("legal_name") @db.VarChar(150) // New field for Seller/Deposit verification

  // Address
  address    String? @db.Text
  city       String? @db.VarChar(100)
  country    String? @db.VarChar(100)
  postalCode String? @map("postal_code") @db.VarChar(20)

  @@index([userId], name: "idx_profiles_user")
  @@map("profiles")
}

/// Session - User sessions for refresh tokens
model Session {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relation
  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Token
  refreshToken String   @unique @map("refresh_token") @db.VarChar(255)
  expiresAt    DateTime @map("expires_at") @db.Timestamptz

  // Session metadata
  ipAddress  String?   @map("ip_address") @db.VarChar(50)
  userAgent  String?   @map("user_agent") @db.Text
  lastUsedAt DateTime? @map("last_used_at") @db.Timestamptz
  revokedAt  DateTime? @map("revoked_at") @db.Timestamptz

  @@index([userId], name: "idx_sessions_user")
  @@index([refreshToken], name: "idx_sessions_token")
  @@index([expiresAt], name: "idx_sessions_expires")
  @@map("sessions")
}

// ===========================================
// AUCTION & COMMERCE TABLES
// ===========================================

/// Auction - Core auction entity
model Auction {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Info
  title       String @db.VarChar(200)
  description String @db.Text
  slug        String @unique @db.VarChar(255)
  images      Json   @default("[]") @db.JsonB

  // Pricing & Time
  startingPrice Decimal  @map("starting_price") @db.Decimal(10, 2)
  currentPrice  Decimal  @map("current_price") @db.Decimal(10, 2)
  startsAt      DateTime @map("starts_at") @db.Timestamptz
  endsAt        DateTime @map("ends_at") @db.Timestamptz

  // Status
  status AuctionStatus @default(DRAFT)

  // Relations
  sellerId String @map("seller_id") @db.Uuid
  seller   User   @relation(fields: [sellerId], references: [id])
  bids     Bid[]
  watchlist Watchlist[]

  order Order? // One-to-One relation: Auction -> Order

  @@index([sellerId], name: "idx_auctions_seller")
  @@index([status], name: "idx_auctions_status")
  @@index([endsAt], name: "idx_auctions_ends_at")
  @@map("auctions")
}

/// Bid - Auction bid entity
model Bid {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Amount
  amount Decimal @db.Decimal(10, 2)

  // Relations
  auctionId String  @map("auction_id") @db.Uuid
  auction   Auction @relation(fields: [auctionId], references: [id])

  bidderId String @map("bidder_id") @db.Uuid
  bidder   User   @relation(fields: [bidderId], references: [id])

  @@index([auctionId], name: "idx_bids_auction")
  @@index([bidderId], name: "idx_bids_bidder")
  @@index([amount], name: "idx_bids_amount")
  @@index([auctionId, amount(sort: Desc)], name: "idx_bids_auction_amount")
  @@map("bids")
}

/// Watchlist - User watched auctions (Spec v0.2.3)
model Watchlist {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  userId    String   @map("user_id") @db.Uuid
  user      User     @relation(fields: [userId], references: [id])

  auctionId String   @map("auction_id") @db.Uuid
  auction   Auction  @relation(fields: [auctionId], references: [id])

  @@unique([userId, auctionId])
  @@index([userId], name: "idx_watchlist_user")
  @@map("watchlist")
}

/// Order Status enum
enum OrderStatus {
  PENDING_PAYMENT
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

/// Order - Post-auction transaction
model Order {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Info
  totalAmount Decimal     @map("total_amount") @db.Decimal(10, 2)
  status      OrderStatus @default(PENDING_PAYMENT)

  // Relations
  auctionId String  @unique @map("auction_id") @db.Uuid
  auction   Auction @relation(fields: [auctionId], references: [id])

  buyerId String @map("buyer_id") @db.Uuid
  buyer   User   @relation("OrdersBuyer", fields: [buyerId], references: [id])

  sellerId String @map("seller_id") @db.Uuid
  seller   User   @relation("OrdersSeller", fields: [sellerId], references: [id])

  payments Payment[]
  shipment Shipment?
  ratings  Rating[]
  dispute  Dispute?

  @@index([buyerId], name: "idx_orders_buyer")
  @@index([sellerId], name: "idx_orders_seller")
  @@index([status], name: "idx_orders_status")
  @@map("orders")
}

/// Payment Provider enum
enum PaymentProvider {
  MERCADO_PAGO
  PAYPAL
  STRIPE
}

/// Payment Status enum
enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

/// Payment - Transaction records
model Payment {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Transaction Info
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("USD") @db.VarChar(3)

  provider PaymentProvider
  status   PaymentStatus   @default(PENDING)

  // External Ref
  externalId String? @map("external_id") @db.VarChar(255)
  metadata   Json    @default("{}") @db.JsonB

  // Relations
  orderId String @map("order_id") @db.Uuid
  order   Order  @relation(fields: [orderId], references: [id])

  @@index([orderId], name: "idx_payments_order")
  @@index([externalId], name: "idx_payments_external_id")
  @@index([status], name: "idx_payments_status")
  @@map("payments")
}

// ===========================================
// LOGISTICS TABLES
// ===========================================

/// Shipment Status enum
enum ShipmentStatus {
  PENDING
  SHIPPED
  DELIVERED
  RETURNED
}

/// Shipment Provider enum
enum ShipmentProvider {
  DHL
  FEDEX
  ESTAFETA
  UPS
  CUSTOM
}

/// Shipment - Logistics records
model Shipment {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Tracking Info
  provider       ShipmentProvider
  trackingNumber String?          @map("tracking_number") @db.VarChar(100)
  status         ShipmentStatus   @default(PENDING)

  // Timestamps
  estimatedDelivery DateTime? @map("estimated_delivery") @db.Timestamptz
  shippedAt         DateTime? @map("shipped_at") @db.Timestamptz
  deliveredAt       DateTime? @map("delivered_at") @db.Timestamptz

  // Relations
  orderId String @unique @map("order_id") @db.Uuid
  order   Order  @relation(fields: [orderId], references: [id])

  @@index([orderId], name: "idx_shipments_order")
  @@index([status], name: "idx_shipments_status")
  @@map("shipments")
}

/// Rating - User reputation feedback
model Rating {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Info
  score   Int     @db.SmallInt // 1-5
  comment String? @db.Text

  // Relations
  orderId String @map("order_id") @db.Uuid
  order   Order  @relation(fields: [orderId], references: [id])

  authorId String @map("author_id") @db.Uuid
  author   User   @relation("RatingAuthor", fields: [authorId], references: [id])

  targetId String @map("target_id") @db.Uuid
  target   User   @relation("RatingTarget", fields: [targetId], references: [id])

  @@index([orderId], name: "idx_ratings_order")
  @@index([authorId], name: "idx_ratings_author")
  @@index([targetId], name: "idx_ratings_target")
  @@map("ratings")
}

/// Dispute Status enum
enum DisputeStatus {
  OPEN
  IN_MEDIATION
  RESOLVED
  CLOSED
}

/// Dispute - Transaction conflict
model Dispute {
  id          String        @id @default(uuid()) @db.Uuid
  orderId     String        @unique @map("order_id") @db.Uuid
  creatorId   String        @map("creator_id") @db.Uuid
  reason      String        @db.VarChar(100)
  description String        @db.Text
  status      DisputeStatus @default(OPEN)
  resolution  String?       @db.Text
  createdAt   DateTime      @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime      @updatedAt @map("updated_at") @db.Timestamptz

  order   Order @relation(fields: [orderId], references: [id])
  creator User  @relation("DisputeCreator", fields: [creatorId], references: [id])

  @@index([orderId], name: "idx_disputes_order")
  @@index([creatorId], name: "idx_disputes_creator")
  @@index([status], name: "idx_disputes_status")
  @@map("disputes")
}

/// Notification Type enum
enum NotificationType {
  AUCTION_WON
  AUCTION_LOST
  BID_OUTBID
  ORDER_PAID
  ORDER_SHIPPED
  DISPUTE_UPDATE
  SYSTEM
}

/// Notification - User alerts
model Notification {
  id        String           @id @default(uuid()) @db.Uuid
  userId    String           @map("user_id") @db.Uuid
  type      NotificationType
  title     String           @db.VarChar(200)
  message   String           @db.Text
  data      Json             @default("{}") @db.JsonB
  isRead    Boolean          @default(false) @map("is_read")
  createdAt DateTime         @default(now()) @map("created_at") @db.Timestamptz

  user User @relation(fields: [userId], references: [id])

  @@index([userId], name: "idx_notifications_user")
  @@index([isRead], name: "idx_notifications_read")
  @@map("notifications")
}

// ===========================================
// OBSERVABILITY TABLES
// Reference: 03-modelo-registro-db.md
// ===========================================

/// Audit Events - Business events for auditing
/// Stores all significant business actions (bids, payments, etc.)
model AuditEvent {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Event identification
  eventType String   @map("event_type") @db.VarChar(100)
  timestamp DateTime @default(now()) @db.Timestamptz

  // Correlation
  traceId String @map("trace_id") @db.VarChar(100)
  env     String @db.VarChar(20)
  service String @db.VarChar(50)

  // Actor information
  actorType   String  @map("actor_type") @db.VarChar(20) // 'user' | 'system'
  actorUserId String? @map("actor_user_id") @db.Uuid

  // Target entity
  entityType String @map("entity_type") @db.VarChar(50)
  entityId   String @map("entity_id") @db.Uuid

  // Result
  result     String  @db.VarChar(20) // 'SUCCESS' | 'FAIL'
  reasonCode String? @map("reason_code") @db.VarChar(100)

  // Payload (whitelisted data only)
  payload        Json @default("{}") @db.JsonB
  payloadVersion Int  @default(1) @map("payload_version")

  @@index([entityType, entityId, timestamp(sort: Desc)], name: "idx_audit_events_entity")
  @@index([actorUserId, timestamp(sort: Desc)], name: "idx_audit_events_actor")
  @@index([traceId], name: "idx_audit_events_trace")
  @@index([eventType, timestamp(sort: Desc)], name: "idx_audit_events_type_time")
  @@map("audit_events")
}

/// Error Events - Captured errors (business + exceptions)
/// Stores all errors for debugging and monitoring
model ErrorEvent {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Correlation
  timestamp DateTime @default(now()) @db.Timestamptz
  traceId   String   @map("trace_id") @db.VarChar(100)
  env       String   @db.VarChar(20)
  service   String   @db.VarChar(50)

  // Error details
  errorCode       String  @map("error_code") @db.VarChar(100)
  message         String  @db.Text
  severity        String  @db.VarChar(20) // 'WARN' | 'ERROR'
  httpStatus      Int?    @map("http_status")
  isBusinessError Boolean @default(false) @map("is_business_error")

  // Request context
  httpMethod String? @map("http_method") @db.VarChar(10)
  httpPath   String? @map("http_path") @db.Text
  httpQuery  String? @map("http_query") @db.Text
  clientIp   String? @map("client_ip") @db.VarChar(50)
  userAgent  String? @map("user_agent") @db.Text

  // Actor
  actorUserId String? @map("actor_user_id") @db.Uuid

  // Target entity (if applicable)
  entityType String? @map("entity_type") @db.VarChar(50)
  entityId   String? @map("entity_id") @db.Uuid

  // Additional details
  details Json    @default("{}") @db.JsonB
  stack   String? @db.Text

  @@index([traceId], name: "idx_error_events_trace")
  @@index([errorCode, timestamp(sort: Desc)], name: "idx_error_events_code_time")
  @@index([actorUserId, timestamp(sort: Desc)], name: "idx_error_events_actor")
  @@index([entityType, entityId, timestamp(sort: Desc)], name: "idx_error_events_entity")
  @@index([httpStatus, timestamp(sort: Desc)], name: "idx_error_events_http")
  @@map("error_events")
}

/// Request Logs - HTTP request/response logs
/// For diagnostics and performance monitoring
model RequestLog {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Correlation
  timestamp DateTime @default(now()) @db.Timestamptz
  traceId   String   @map("trace_id") @db.VarChar(100)
  env       String   @db.VarChar(20)
  service   String   @db.VarChar(50)

  // Request/Response
  httpMethod        String @map("http_method") @db.VarChar(10)
  httpPath          String @map("http_path") @db.Text
  httpStatus        Int    @map("http_status")
  durationMs        Int    @map("duration_ms")
  requestSizeBytes  Int?   @map("request_size_bytes")
  responseSizeBytes Int?   @map("response_size_bytes")

  // Actor
  actorUserId String? @map("actor_user_id") @db.Uuid
  actorState  String? @map("actor_state") @db.VarChar(50)

  // Client info
  clientIp  String? @map("client_ip") @db.VarChar(50)
  userAgent String? @map("user_agent") @db.Text
  clientApp String? @map("client_app") @db.VarChar(20)

  // Target entity (optional)
  entityType String? @map("entity_type") @db.VarChar(50)
  entityId   String? @map("entity_id") @db.Uuid

  @@index([traceId], name: "idx_request_logs_trace")
  @@index([httpPath, timestamp(sort: Desc)], name: "idx_request_logs_path_time")
  @@index([httpStatus, timestamp(sort: Desc)], name: "idx_request_logs_status_time")
  @@index([actorUserId, timestamp(sort: Desc)], name: "idx_request_logs_actor_time")
  @@map("request_logs")
}

// ===========================================
// WALLET & LEDGER TABLES
// ===========================================

/// Ledger entry type enum
enum LedgerType {
  DEPOSIT
  WITHDRAWAL
  HOLD_BID
  RELEASE_BID
  PURCHASE        // Keep for backward compatibility or alias to DEBIT_ORDER if needed, but Spec says DEBIT_ORDER
  DEBIT_ORDER     // New
  CREDIT_SALE     // New
  FEE_PLATFORM    // New
  REFUND
  ADJUSTMENT
}

/// Wallet - User's financial account
model Wallet {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Ownership
  userId String @unique @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id])

  // Balance
  balance   Decimal @default(0) @db.Decimal(12, 2) // Available funds
  heldFunds Decimal @default(0) @map("held_funds") @db.Decimal(12, 2) // Locked in active bids
  currency  String  @default("USD") @db.VarChar(3)

  // System State
  isActive Boolean @default(false) @map("is_active") // Requires initial deposit

  // Relations
  ledgerEntries Ledger[]

  @@map("wallets")
}

/// Ledger - Immutable financial history
model Ledger {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relation
  walletId String @map("wallet_id") @db.Uuid
  wallet   Wallet @relation(fields: [walletId], references: [id])

  // Movement details
  type          LedgerType
  amount        Decimal    @db.Decimal(12, 2)
  balanceBefore Decimal    @map("balance_before") @db.Decimal(12, 2)
  balanceAfter  Decimal    @map("balance_after") @db.Decimal(12, 2)

  // Reference (Audit)
  referenceId   String? @map("reference_id") @db.VarChar(100) // AuctionID, PaymentID, etc.
  referenceType String? @map("reference_type") @db.VarChar(50) // "AUCTION", "PAYMENT"
  description   String  @db.Text

  @@index([walletId, createdAt(sort: Desc)], name: "idx_ledger_wallet_time")
  @@index([referenceId], name: "idx_ledger_reference")
  @@map("ledger")
}
